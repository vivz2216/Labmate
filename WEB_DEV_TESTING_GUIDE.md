# Web Development Features - Testing Guide

## Prerequisites

Before testing, ensure:
1. Docker and Docker Compose are installed and running
2. Docker socket is accessible at `/var/run/docker.sock`
3. All backend and frontend services are rebuilt with new changes

## Rebuild and Restart

```bash
# Stop all services
docker compose down

# Rebuild backend with new dependencies and Docker CLI
docker compose build backend

# Start all services
docker compose up -d

# Check backend logs
docker compose logs -f backend
```

## Test Cases

### 1. HTML/CSS/JS Test

#### Sample Lab Code
```html
<!DOCTYPE html>
<html>
<head>
    <title>Hello World</title>
    <style>
        body {
            background: lightblue;
            font-family: Arial;
            text-align: center;
            padding: 50px;
        }
        h1 {
            color: #333;
        }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Page loaded!');
            document.write('<p>Generated by JavaScript</p>');
        });
    </script>
</head>
<body>
    <h1>Hello, World!</h1>
</body>
</html>
```

#### Steps
1. Create a lab manual (DOCX/PDF) with the above HTML code
2. Upload to LabMate dashboard
3. Select "HTML/CSS/JS (VS Code)"
4. Review AI suggestions
5. Submit task for execution
6. Verify screenshot shows:
   - VS Code editor with HTML syntax highlighting
   - Browser preview showing rendered page with light blue background

#### Expected Output
- Status: Success
- Screenshot: Two sections (Editor + Browser)
- Execution time: ~3-5 seconds
- Console logs captured (if any)

---

### 2. React Test

#### Sample Lab Code
```jsx
import React from 'react'

function App() {
  const [count, setCount] = React.useState(0)
  
  return (
    <div style={{ textAlign: 'center', padding: '50px' }}>
      <h1>React Counter</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  )
}

export default App
```

#### Steps
1. Create a lab manual with the above React code
2. Upload to LabMate
3. Select "React (VS Code)"
4. Review AI suggestions
5. Submit task for execution
6. Verify screenshot shows:
   - VS Code editor with JSX syntax highlighting
   - React icon in tab
   - Browser preview showing rendered component

#### Expected Output
- Status: Success
- Screenshot: Two sections (Editor + Browser)
- Execution time: ~20-30 seconds (includes npm install + Vite build)
- Browser shows "React Counter" heading

**Note**: First React execution will take longer due to npm install. Subsequent executions may be faster if Docker caches layers.

---

### 3. Node.js/Express Test

#### Sample Lab Code
```javascript
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello from Express Server!');
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

#### Steps
1. Create a lab manual with the above Express code
2. Upload to LabMate
3. Select "Node.js/Express (VS Code)"
4. Review AI suggestions
5. Submit task for execution
6. Verify screenshot shows:
   - VS Code editor with JavaScript syntax highlighting
   - Node.js icon in tab
   - Terminal showing `node server.js` command
   - Server response: "Hello from Express Server!"

#### Expected Output
- Status: Success
- Screenshot: Two sections (Editor + Terminal)
- Execution time: ~10-15 seconds
- Terminal shows server startup message and response

---

## Debugging

### Check Backend Logs
```bash
docker compose logs -f backend
```

Look for:
- `Created temporary HTML file: /tmp/html_...`
- `Created temporary React project: /tmp/react_...`
- `Created temporary Node project: /tmp/node_...`
- `Spawning Node.js Docker container: react_xxxxx`
- `Waiting for Vite dev server to start...`
- `HTML/React/Node execution completed successfully`

### Check Docker Containers
```bash
# List running containers (should show spawned node:20-slim containers)
docker ps

# Check if Docker socket is mounted
docker compose exec backend ls -la /var/run/docker.sock
```

### Common Issues

#### Issue 1: "Docker socket not found"
**Solution**: Ensure Docker socket is mounted in `docker-compose.yml`:
```yaml
volumes:
  - /var/run/docker.sock:/var/run/docker.sock
```

#### Issue 2: "Permission denied accessing Docker socket"
**Solution**: Add backend user to docker group or run with appropriate permissions:
```bash
# On host machine
sudo chmod 666 /var/run/docker.sock
```

#### Issue 3: "Port 3000/3001 already in use"
**Solution**: 
- Stop any services using those ports
- Or wait for previous container to terminate
- Containers should auto-cleanup after execution

#### Issue 4: "npm install failed"
**Solution**:
- Check network connectivity
- Verify whitelisted packages are correct
- Check npm registry is accessible

#### Issue 5: "React/Vite build timeout"
**Solution**:
- Increase `WEB_EXECUTION_TIMEOUT_REACT` in config
- Simplify React component (remove heavy dependencies)

#### Issue 6: "Playwright failed to load page"
**Solution**:
- Ensure Chromium is installed in backend container
- Check if port forwarding is working
- Verify server actually started (check container logs)

---

## Manual Testing with curl

### Test HTML Execution Directly
```bash
# SSH into backend container
docker compose exec backend bash

# Create test HTML file
cat > /tmp/test.html << 'EOF'
<!DOCTYPE html>
<html>
<body><h1>Test</h1></body>
</html>
EOF

# Test Playwright can render it
python3 -c "
import asyncio
from playwright.async_api import async_playwright

async def test():
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()
        await page.goto('file:///tmp/test.html')
        content = await page.content()
        print(content)
        await browser.close()

asyncio.run(test())
"
```

### Test Docker-in-Docker
```bash
# Inside backend container
docker run --rm node:20-slim node --version
# Should print Node.js version if Docker-in-Docker works
```

---

## Performance Benchmarks

Track these metrics during testing:

| Language | Avg Execution Time | Peak Memory | Container Startup |
|----------|-------------------|-------------|-------------------|
| HTML     | ~3-5s             | <100MB      | N/A (no container)|
| React    | ~20-30s           | ~800MB      | ~5s               |
| Node.js  | ~10-15s           | ~400MB      | ~3s               |

---

## Success Criteria

✅ HTML renders correctly in browser preview  
✅ Console logs are captured  
✅ React component builds and renders  
✅ React dev server starts within timeout  
✅ Express server responds to requests  
✅ Terminal output shows server logs  
✅ Screenshots match VS Code theme  
✅ Containers cleanup after execution  
✅ No port conflicts  
✅ No memory leaks  

---

## Next Steps After Testing

1. **If HTML works**: Proceed to React testing
2. **If React works**: Proceed to Node.js testing
3. **If all work**: Test with real lab manuals from students
4. **If issues found**: Check logs, adjust timeouts, fix bugs
5. **After successful testing**: Update documentation and deploy to staging

---

## Contact

For issues or questions during testing, check:
- Backend logs: `docker compose logs backend`
- Frontend logs: `docker compose logs frontend`
- Browser console: Check Network tab and Console tab
- This implementation summary: `WEB_DEV_IMPLEMENTATION_SUMMARY.md`

